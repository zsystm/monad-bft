// DO NOT EDIT THIS FILE! If you need changes, change the code generator
// instead. This file was generated by running the following command:
//
//    util/ctypes/codegen/cg-ctypes -s libs/execution/ctypes rust -p
//    /home/ken/src/monad-bft/monad-exec-events/src -frustfmt +nightly

//! Definitions of event payloads used with the EXEC event ring

#![allow(non_camel_case_types)]
#![allow(unused_imports)]

use alloy_primitives::{Address, B256, U256};
use monad_event_ring::event_metadata::*;

use crate::eth_ctypes::*;

/// Each type of event is assigned a unique value in this enumeration
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq)]
#[repr(u16)]
pub enum exec_event_type {
    #[default]
    NONE,
    BLOCK_START,
    BLOCK_END,
    BLOCK_QC,
    BLOCK_FINALIZED,
    BLOCK_VERIFIED,
    BLOCK_REJECT,
    TXN_START,
    TXN_REJECT,
    TXN_RECEIPT,
    TXN_LOG,
    TXN_CALL_FRAME,
    ACCOUNT_ACCESS_LIST_HEADER,
    ACCOUNT_ACCESS,
    STORAGE_ACCESS,
    EVM_ERROR,
}

/// Stored in event descriptor `user[0]` field to tag the block & transaction
/// context of event
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct flow_info {
    pub block_flow_id: u16, // Index into block flow metadata array
    pub txn_id: u32,        // txn id == txn_num + 1; id 0 -> no txn
}

/// Information about a proposal that is signed during the voting process to
/// produce a quorum certificate.
///
/// The consensus decision is to agree that a particular proposed block becomes
/// the canonical block with a particular height. This is accomplished by
/// voting, via the cryptographic signing of the summary data in this object.
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct proposal_metadata {
    pub round: u64,        // Round of block proposal
    pub epoch: u64,        // Epoch of block proposal
    pub block_number: u64, // Proposal is to become this block
    pub id: B256,          // Monad consensus unique ID for proposal
    pub parent_round: u64, // Parent round of proposed block
    pub parent_id: B256,   // Consensus unique ID of parent block
}

/// Event recorded at the start of block execution
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_header {
    pub proposal: proposal_metadata, // Execution is for this proposed block
    pub parent_eth_hash: B256,       // Hash of Ethereum parent block
    pub chain_id: U256,              // Block chain we're associated with
    pub exec_input: eth_block_exec_input, // Ethereum execution inputs
}

/// Event recorded upon successful block execution
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_result {
    pub eth_block_hash: B256,               // Hash of Ethereum block
    pub exec_output: eth_block_exec_output, // Ethereum execution outputs
}

/// Event recorded when a proposed block obtains a quorum certificate
pub type block_qc = proposal_metadata;

/// Event recorded when consensus finalizes a block
pub type block_finalized = proposal_metadata;

/// Event recorded when consensus verifies the state root of a finalized block
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct block_verified {
    pub block_number: u64, // Number of verified block
}

/// Event recorded when a block is rejected (i.e., is invalid)
///
/// This corresponds to a value in the `BlockError` enumeration in
/// `validate_block.hpp`, in the execution repo source code.
pub type block_reject = u32;

/// Event recorded when transaction processing starts
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct txn_start {
    pub txn_hash: B256,             // Keccak hash of transaction RLP
    pub sender: Address,            // Recovered sender address
    pub txn_header: eth_txn_header, // Transaction header
}

/// Event recorded when a transaction is rejected (i.e., is invalid)
///
/// This corresponds to a value in the `TransactionError` enumeration in
/// `validate_transaction.hpp`, in the execution repo source code.
pub type txn_reject = u32;

/// Event recorded when transaction execution halts
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct txn_receipt {
    pub receipt: eth_txn_receipt, // Incremental Ethereum receipt
    pub call_frame_count: u32,    // Number of call frames
}

/// Event recorded when a transaction emits a LOG
pub type txn_log = eth_txn_log;

/// Event recorded when a call frame is emitted.
///
/// Trace information about an execution context that was created during an EVM
/// contract invocation ("call"), or contract creation.
///
/// Formally, the EVM operates through concepts called 'message calls' and
/// 'contract creations'. Each of these defines an execution environment, which
/// contains data such as the account causing the code to execute. A formal list
/// of all the items in the environment is part of the official specification.
///
/// Each call (and contract creation) gets its own environment. The environments
/// are set up in different ways, depending on how the call occurs (e.g., a CALL
/// vs. DELEGATECALL opcode). A call frame is a summary of the inputs and
/// outputs to an execution environment, whether the halting was normal or
/// exceptional, and other information useful for tracing the call tree.
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct txn_call_frame {
    pub index: u32,           // Array index of call frame
    pub caller: Address,      // Address initiating call
    pub call_target: Address, // Address receiving call (or deployment addr)
    pub opcode: u8,           // EVM opcode that creates frame
    pub value: U256,          // I_v: value passed to account during execution
    pub gas: u64,             // g: gas available for message execution
    pub gas_used: u64,        // Gas used by call
    pub evmc_status: i32,     // evmc_status_code of call
    pub depth: u64,           // I_e: depth of call context stack
    pub input_length: u64,    // Length of trailing call input
    pub return_length: u64,   // Length of trailing return data
}

/// Context in which EVM accessed / modified an account
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
#[repr(u8)]
pub enum account_access_context {
    #[default]
    BLOCK_PROLOGUE,
    TRANSACTION,
    BLOCK_EPILOGUE,
}

/// Header event that precedes a variably-sized list of account_access objects
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct account_access_list_header {
    pub entry_count: u32, // Number of account_access_entry events
    pub access_context: account_access_context, // Context of account accesses
}

/// Event emitted when an account is read or written
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct account_access {
    pub index: u32,                             // Index in accessed account list
    pub address: Address,                       // Address of account
    pub access_context: account_access_context, // Context of account access
    pub is_balance_modified: bool,              // True -> modified_balance meaningful
    pub is_nonce_modified: bool,                // True -> modified_nonce meaningful
    pub prestate: eth_account_state,            // Read (or original) balance
    pub modified_balance: U256,                 // New balance, if modified
    pub modified_nonce: u64,                    // New nonce, if modified
    pub storage_key_count: u32,                 // Number of trailing storage_access events
    pub transient_count: u32,                   // As above, but for transient storage
}

/// Event emitted for each account storage key that is accessed
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct storage_access {
    pub address: Address,                       // Address of storage account
    pub index: u32,                             // Index of storage records in this context
    pub access_context: account_access_context, // Context of account access
    pub modified: bool,                         // True -> new_value meaningful
    pub transient: bool,                        // True -> is transient storage
    pub key: B256,                              // Storage key accessed / modified
    pub start_value: B256,                      // Read (or original) value
    pub end_value: B256,                        // New value, if modified
}

/// Error occurred in execution process (not a validation error)
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[repr(C)]
pub struct evm_error {
    pub domain_id: u64,   // Boost.Outcome domain id of error
    pub status_code: i64, // Boost.Outcome status code of error
}

pub fn format_as(bytes: &[u8], event_type: exec_event_type) -> String {
    match event_type {
        exec_event_type::NONE => String::from("NONE"),
        exec_event_type::BLOCK_START => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_header) })
        }
        exec_event_type::BLOCK_END => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_result) })
        }
        exec_event_type::BLOCK_QC => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_qc) })
        }
        exec_event_type::BLOCK_FINALIZED => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const block_finalized)
        }),
        exec_event_type::BLOCK_VERIFIED => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const block_verified)
        }),
        exec_event_type::BLOCK_REJECT => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const block_reject) })
        }
        exec_event_type::TXN_START => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const txn_start) })
        }
        exec_event_type::TXN_REJECT => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const txn_reject) })
        }
        exec_event_type::TXN_RECEIPT => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const txn_receipt) })
        }
        exec_event_type::TXN_LOG => format!("{:?}", unsafe { *(bytes.as_ptr() as *const txn_log) }),
        exec_event_type::TXN_CALL_FRAME => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const txn_call_frame)
        }),
        exec_event_type::ACCOUNT_ACCESS_LIST_HEADER => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const account_access_list_header)
        }),
        exec_event_type::ACCOUNT_ACCESS => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const account_access)
        }),
        exec_event_type::STORAGE_ACCESS => format!("{:?}", unsafe {
            *(bytes.as_ptr() as *const storage_access)
        }),
        exec_event_type::EVM_ERROR => {
            format!("{:?}", unsafe { *(bytes.as_ptr() as *const evm_error) })
        }
    }
}

pub const EXEC_EVENT_METADATA: [EventMetadata; 16] = [
    EventMetadata {
        event_type: exec_event_type::NONE as u16,
        c_name: "NONE",
        description: "Reserved code so that 0 remains invalid",
    },
    EventMetadata {
        event_type: exec_event_type::BLOCK_START as u16,
        c_name: "BLOCK_START",
        description: "Event recorded at the start of block execution",
    },
    EventMetadata {
        event_type: exec_event_type::BLOCK_END as u16,
        c_name: "BLOCK_END",
        description: "Event recorded upon successful block execution",
    },
    EventMetadata {
        event_type: exec_event_type::BLOCK_QC as u16,
        c_name: "BLOCK_QC",
        description: "Event recorded when a proposed block obtains a quorum certificate",
    },
    EventMetadata {
        event_type: exec_event_type::BLOCK_FINALIZED as u16,
        c_name: "BLOCK_FINALIZED",
        description: "Event recorded when consensus finalizes a block",
    },
    EventMetadata {
        event_type: exec_event_type::BLOCK_VERIFIED as u16,
        c_name: "BLOCK_VERIFIED",
        description: "Event recorded when consensus verifies the state root of a finalized block",
    },
    EventMetadata {
        event_type: exec_event_type::BLOCK_REJECT as u16,
        c_name: "BLOCK_REJECT",
        description: "Event recorded when a block is rejected (i.e., is invalid)",
    },
    EventMetadata {
        event_type: exec_event_type::TXN_START as u16,
        c_name: "TXN_START",
        description: "Event recorded when transaction processing starts",
    },
    EventMetadata {
        event_type: exec_event_type::TXN_REJECT as u16,
        c_name: "TXN_REJECT",
        description: "Event recorded when a transaction is rejected (i.e., is invalid)",
    },
    EventMetadata {
        event_type: exec_event_type::TXN_RECEIPT as u16,
        c_name: "TXN_RECEIPT",
        description: "Event recorded when transaction execution halts",
    },
    EventMetadata {
        event_type: exec_event_type::TXN_LOG as u16,
        c_name: "TXN_LOG",
        description: "Event recorded when a transaction emits a LOG",
    },
    EventMetadata {
        event_type: exec_event_type::TXN_CALL_FRAME as u16,
        c_name: "TXN_CALL_FRAME",
        description: "Event recorded when a call frame is emitted.",
    },
    EventMetadata {
        event_type: exec_event_type::ACCOUNT_ACCESS_LIST_HEADER as u16,
        c_name: "ACCOUNT_ACCESS_LIST_HEADER",
        description: "Header event that precedes a variably-sized list of account_access objects",
    },
    EventMetadata {
        event_type: exec_event_type::ACCOUNT_ACCESS as u16,
        c_name: "ACCOUNT_ACCESS",
        description: "Event emitted when an account is read or written",
    },
    EventMetadata {
        event_type: exec_event_type::STORAGE_ACCESS as u16,
        c_name: "STORAGE_ACCESS",
        description: "Event emitted for each account storage key that is accessed",
    },
    EventMetadata {
        event_type: exec_event_type::EVM_ERROR as u16,
        c_name: "EVM_ERROR",
        description: "Error occurred in execution process (not a validation error)",
    },
];

pub static EXEC_EVENT_DOMAIN_METADATA: EventDomainMetadata = EventDomainMetadata {
    metadata_hash: [
        0x64, 0xfb, 0xe5, 0xa7, 0x85, 0x1e, 0x99, 0xad, 0x74, 0xec, 0xf6, 0x56, 0x11, 0x8e, 0xa3,
        0x41, 0x5f, 0xb9, 0xe6, 0x6c, 0x81, 0xed, 0xf4, 0x33, 0x4a, 0xa2, 0x5d, 0xee, 0x87, 0x6b,
        0x65, 0xdf,
    ],
    events: &EXEC_EVENT_METADATA,
};

pub const EXEC_EVENT_DEFAULT_RING_PATH: &str = "/dev/hugepages/monad-exec-events";
